# 操作系统的运行机制
## 操作系统的基本框架

<p align="center"><img width="70%" src="../images/os_framework.png"></p>

由操作系统内核去管理的程序为内核程序(计算机底层软件 --> 大内核、微内核)<br/>
在用户空间中(非必需)的程序为应用程序
<br/>
我们所关注的操作系统的运行机制集中在内核空间
<br/>  
CPU的运行状态分为

+ 用户态     --> 执行内核程序
+ 核心态     --> 执行用户程序
+ 管态/目态  --> 中断（访管指令或系统调用）  实现用户/核心态的切换的唯一方式
  <br/>

对CPU而言所有人都是程序，如何鉴别应当切换到用户态呢？<br/>
-->将程序状态字切换到1为用户态/到0时则在核心态运转

内核三大支撑功能：
+ 时钟管理
+ 中断处理
+ 原语操作

## 时钟管理
+ 计时：为应用程序提供标准系统时间

+ 中断机制

## <font color="red">中断机制</font>
+ 提高多道程序环境下CPU的利用率（并发）
    + CPU在执行某个app的I/O比较慢，干等着不如切换到另一个app去做动作
+ 中断信号的分类
    + 若是来源于外部设备则是外中断（别的设备告诉CPU你该中断处理问题了--被迫中断）
    + 若来源于当前程序内部的指令则是内中断（自愿协商中断），分三种情况：
        + 陷阱/陷入（Trap）<-- 应用程序引发，由CPU产生而并非由应用程序产生<br/>
          --> 进行系统调用的过程 进入陷阱态后会切换到内核态去执行程序
          <p align="left"><img width="90%" src="../images/break.png"></p>

            +   系统调用是操作系统实现的一整套接口，方便app通过这一套接口去访问内核服务 通过陷入指令（**在用户这一端执行的**）去执行对应的处理程序 从用户态切换到内核态
            +   之所以这样实现系统调用 如此繁琐 是为了确保安全性

        + 故障（fault） <-- 由错误条件引发
            + 故障中断在调用处理程序处理完后 会继续执行当前指令的后续指令<br/> 而不是切换到核心态直接执行特权指令

        + 终止（abort） <-- 由致命错误引发（错误程度重）
            + 比如碰到地址越界、非法操作码、非法访问特权指令等严重情况
            + 程序不要执行了，调用处理程序直接shut down

    + 中断的具体处理过程(内外中断皆可适用)三步曲（硬件来实现）：

        <p align="left"><img width="100%" src="../images/break_process.png"></p>

        + 保留犯罪现场和屏蔽字
            + 引出中断服务程序不代表执行
            + 关中断是不再接受更高级的中断，一直到把现场和屏蔽字保存完成后再开中断（可以再相应其他中断）
        + 执行中断服务程序（**每个中断都对应有相应的中断服务程序**）
        + 恢复犯罪现场和屏蔽字


## 原语操作
+ 进程控制的过程需要创建新进程、撤销已有进程、挂起、阻塞、唤醒、进程切换等等。而这些控制操作都需要一系列指令来实现。
+   所谓原语，就是是由多个指令组成的程序段（公用的小程序） 来完成进程控制的某个特定功能  比如纯粹地读或写固定字长、进程调度的一部分（每个状态转换都有相应的原语完成对应操作）、文件读取的一部分...
    + 是对于一系列指令进行的封装 使得能够应对相对频繁地调用 （python函数的设计）执行时间比较多
+   原语在内核空间中运行 调用频繁 --> 相对比较短  不能特别长 否则影响效率
+   原语的“原子性” -- 执行过程不可被中断（不能理解为不可再分的操作  原语就是一系列操作 但整体不可中断）
    + 安全性在原语运转过程中需要首先保证 不能在执行原语的过程中间被打断 切换到别的模式状态去
    + 底层实现是中断处理过程保存犯罪现场过程中间的关中断+开中断的组合
