# 进程管理

可能用到的索引标签：
<br/>
<a href="#thread">线程（Thread）与进程之关联</a>


## 何谓进程（Process）？
- 进程是程序的一次执行 --> an instance of a computer that is being executed
    - 程序躺在磁盘上不叫进程 运行起来才算
    - 因此一定是活动状态（进程的动态性）-->进程是一个程序（加载到内存中）及其数据在处理机上顺序执行的时候发生的活动
- 进程是OS进行**资源分配（CPU、内存、寄存器、IO设备等计算机资源）的独立单位** 不可再分（进程的独立性）
    - 进程与进程之间地址相互独立

- 进程在内存中的结构是什么样子的？
    <p align="center"><img width="60%" src="../images/process_structure.png"></p>

    - 控制块（PCB） Process Control Block 进程唯一标识 相当于身份证号码
    - 数据段 存原始数据和中间数据
    - 程序段 存在文本区域 可以被同一个应用程序的多个进程共享（进程的并发性）
        - 比如启动两次浏览器 构建出两个进程  程序是相同的（没必要额外分配空间） 只是数据不同（进程的异步性）

- 进程的状态

    <p align="center"><img width="90%" src="../images/process_situation.JPG"></p>

    - 创建
        - 把完整的进程结构（PCB等）创建出来  把进程丢入就绪队列并将状态设定为就绪
        - OS会根据系统资源决定是否推迟创建， 创建状态为new状态  不能执行 只有创建完成进入就绪队列并将进程状态设定为就绪后才具备执行的可能

    - 就绪（Ready）
        - 能执行而未执行(进程已经分配到了除了CPU之外的所有必要资源--内存分配好了、数据加载好了 只需CPU便可立即执行)
        - 加入就绪*队列*中的进程 经过进程调度 进入执行状态

    - 执行（Running）
        - 执行的时间片完 就把当前进程丢入就绪队列的末尾

    - 阻塞（Blocked）
        - 执行到需要IO申请的时候 CPU不继续执行当前进程 阻塞住 丢进阻塞队列 而CPU去执行其他进程（放弃处理器 暂停执行）
        - 读完磁盘后（IO操作完成后）产生中断，CPU去响应处于阻塞态的进程，把进程加入就绪状态的等待队列
        - 产生阻塞的原因很多  IO申请只是其中一个  还包括申请缓存...

    - 终止
        - 步骤
            - 要把当前进程标记为终止 才不会在下次继续调度它（终止不是原子性的 可以被打断）
            - 资源回收和释放
            - 把唯一标识PCB清空
        - 终止可能的情况
            - 正常：任务完成 没有其他事情可做 执行halt指令 自然结束

            - 异常：内部指令出现异常 比如产生死锁
            - 外界干预：用户人为打断
            - ...


## <h1 id="thread">线程（Thread）与进程之关联</h1>
<a name= "maodian"> </a>

- 线程是进程中的某一条执行路径
    - 进程可以包含多个线程（杀木马 查病毒 电脑体检） 当然也可以只有一个线程
    - 引入线程的目的？
        - 如果没有线程，当一个进程要做很多件事的时候只能串行
        - 每创建一个进程都要重新分配资源，引入线程这种轻型实体作为独立调度和分派的基本单位，使得在同一个进程内部的所有线程都可以共享它们所隶属的进程的所有资源，进一步提高了OS的并发性且减少了资源开销
            - 线程不拥有资源 进程拥有资源 进程拥有的所有资源都归进程本身去管理<br/>
              线程直接去找进程申请资源 要资源 并不对资源拥有所有权<br/>
              这样设计的目的是什么？在进程内部所有线程并发地共享进程的资源可以避免线程间的切换（中断操作，保存现场再调用程序然后恢复现场，如果线程占用大量资源时做这些事会开销很大；而共享进程的资源可以使得线程自己只需保存一些寄存器的内容）
            - 同一个进程中可以不断地在线程之间切换 不会引发进程的调度问题
            - 因此线程相对于进程，大大降低了创建、撤销和切换可执行实体的成本与难度
        - 不同的进程各自下属的线程之间除了通信同步之外是不共享计算机资源的


- 线程是OS**运算调度的最小单位**

- 线程究竟如何实现？
    <p align="center"><img width="90%" src="../images/thread_methods.png"></p>

    - 控制块（唯一标识码）创建于用户态/核心态 --> 称为用户级/内核级线程 （User/Kernel Level Thread)

    - 用户级方式实现 --多对一模型（淘汰）
        - 对于OS内核而言 并不知道有用户级或内核级线程的区别(用户级线程对OS内核不可见)
          <br/>
          这是由于线程所有管理工作归因于进程  因此用户级线程是以一个进程的形式体现给内核的
          <br/>
          因此在调度时，OS内核只知进程而不知线程，OS按照进程进行调度，同一时间其实只能在一个进程完成一个线程的动作，不能并行
        - 当进程要访问内核空间时，所有线程都会阻塞，等到其他进程中的线程做完事情再转回来（本质上是进程切换而非线程切换）

    - 内核级方式实现 --一对一模型
        - 控制块（头部 唯一识别码）在内核空间，而数据和程序段（对识别线程而言不重要的）在用户空间
        - 内核空间实现了多个线程，可以实现线程并行（多个处理机完成多个任务）的效果 -- 真正意义上的线程切换 开销变小了
        - 内核级线程的缺点：切换线程的时候，用户空间的线程到内核空间中线程，内核中线程再到另一个内核中线程，再切换到其对应的用户级线程（切换，线程调度的效率低）；而用户级线程的所有管理动作实现都在用户空间，管理者是当前的进程，线程间切换在进程内部完成，不需要访问内核空间（切换，线程调度效率高）

    - 组合起来  -- 多对多模型
        - 内核空间和用户空间都有线程，用户空间线程往往更多