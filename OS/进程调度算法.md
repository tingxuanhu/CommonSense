# 进程调度的算法

## 先来先服务  First Come First Served （FCFS）
- 依托队列实现
- 最先进就绪队列的最先执行
- CPU繁忙型的适合；IO操作（读写）多的需要频繁切换CPU，不适合，操作耗时导致队列中其他人饥饿


## 短作业优先  Shortset Job First （SJF）
- OS估算每个作业/进程的耗时 短的优先执行 --> 平均周转时间少
- 长作业周转时间可能难以执行，“饥饿"
- 紧迫任务难以保证被及时处理


## 高响应比优先 Highest Response Ratio Next （HRRN）
- 综合等待时间（SJF劣势）和作业周转时间（FCFS不能兼顾）计算响应比 响应比高（长作业且等待时间长）的优先调度
- 只有当前进程放弃执行权（要么完成要么阻塞）重新计算所有进程响应比


## 优先级调度 Priority-Scheduling Algorithm (PSA)
- 最紧迫的最先做
- 可以是抢占式也可以是非抢占式调度
- 优先级设置：
    - 系统>用户  交互型>非交互型   I/O型>计算型
    - 低优先级进程可能“饥饿”  永远等不到执行的那一天


## **时间片轮转调度 Round-Robin (RR)**
- 进程先到就绪队列就先分配时间片(2-200ms)，用时钟计时，时钟硬件设备产生中断，确定时间完毕，中断处理程序剥夺该进程使用权（抢占式）
    - 时间片过大相当于FCFS
    - 时间片过小（进程多，每个进程分到的时间片小）则处理机切换频繁，开销增大
        - radius缓存框架，底层只有单个单个进程，绑定单个处理机，不切换，支持高并发
- 公平、轮流为每个进程服务，进程在一定时间内必然得到响应  --> 适用于分时系统(每个进程分一段时间)，后面进程一定有等待时间，及时性并不强（并不是立刻来了立刻就执行）,难适应实时系统
- 响应时间相对快 CPU调用效率高


## **多级反馈队列 Multileveled Feedback Queue (MFQ)**
--> 手画全过程
<p align="center"><img width="90%" src="../images/mfq.jpg"></p>


- 多个优先级分别设置就绪队列（多个队列）
- 新进程进第一级队列 按FCFS分时间片
    - 短作业优先，优先级越高者分配时间片越小，让更多进程更可能得到执行
    - 若没执行完时间片完毕，则进程降级进下一级就绪队列的队尾(分配到的时间片稍长于该进程在第一队列中被分配的），以此类推
- 优先级高的队列非空时，先执行优先级高的队列，不执行后续队列进程
- 长作业会被执行不会饥饿，只不过可能在前几个队列执行了少部分，可以挪到较低优先级队列再去执行
- 能适应实时系统
    - 交互性强的进程所要求的时间一般不长，进程进入相对优先级较高的队列就能走完
- 批处理作业周转时间也能满足  一个批次一起进一个队列 若有没执行完的 降级再执行