## CodeBlock说明
- 应用场景：多个构造器互相重载 假定每个构造器中间都有类似的重复代码
- 可以收缩到一个代码块中 放在构造器前 这样在执行构造器语句之前会先调用代码块 再调用构造器
- 代码块可以搞成static的（静态代码块） 这样可对类进行初始化 
  - 随着类的加载而执行 且只会执行一次   创建若干个对象 也只会执行一次
    - 类加载的时机？  以下三种情况类加载  这时候静态的块可以随着一起搞起来
      - 第一 创建对象的实例的时候加载
      - 第二 创建子类对象实例之前 一定会先把父类加载了（继承的本质）
      - 第三 使用类的static成员时
- 如果不是static的 就是普通代码块  那么创建一个对象就会调用一次
  - 如果只使用类的静态成员  则普通代码块不会执行(仅仅是构造器中抽象出共性而已)
- 构造器最前隐含了super()调用父类和调用普通代码块的动作   
```java
class A {
    public A() {
        // 隐藏了
//      super();
//      { 自己的代码块 
//      }
      System.out.println("ok");
    }
}
```
- 静态相关的代码块  属性初始化在类加载时就执行完毕了 因此是优先于构造器和普通代码块执行的 
- 总的来讲  创建子类对象的调用顺序：
  - 父类的static代码块和static属性  优先级相同 谁先定义谁先执行
  - 子类的static代码块和static属性  优先级相同 谁先定义谁先执行
  - 父类的普通代码块和普通属性初始化  优先级相同 谁先定义谁先执行
  - 父类的构造器
  - 子类的普通代码块和普通属性初始化  优先级相同 谁先定义谁先执行
  - 子类的构造器
- 特别地：final和static搭配使用可以避免加载类 而只使用属性
```java
class BBB {
    public final static int num = 1000;
    static {
      System.out.println("BBB被执行");
    }
}

public class AAA {
  public static void main(String[] args) {
    System.out.println(BBB.num);   // 因为是final和static搭配  可以跳过代码块与构造器部分 而直接调用静态属性
  }
}


```