# interface 与 abstract class
## 简要对比
|     抽象类     |                    接口                     |
|:-----------:|:-----------------------------------------:|
| 可以存在普通成员函数  |          只能存在public abstract 方法           |
| 成员变量可以是各种类型 | 成员变量只能是public static final型(也就是常量型 这点易忽略) |
|   至多被继承一个   |                 接口可以实现多个                  |

## 深入对比
> 抽象类的设计目的是代码复用(联系Python语言的函数设计的目的) --> 关注提炼事物本质时使用
>   + 表达is a的关系:  BMW is a Car. 对类本质进行抽象。
>   + 先有子类若干，再从中抽象出共性，提炼为抽象类。
>   + 如上所述，抽象类仅实现了子类间重叠的部分(个性部分未能实现)，所以不能实例化。
>   + 抽象类中不一定要有抽象方法，但只要出现了抽象方法（空壳子 定义个方法名字等待子类重写，不允许有方法体）就必须把类声明为抽象类
>     + 抽象方法需要被重写 所以拒绝使用private  final static来修饰
>   + abstract 抽象 只能抽象类和抽象方法  不能作用于属性

>   + 抽象类也是类 所以有继承机制  如果一个类继承抽象类 必须继承抽象类的所有抽象方法 或者也定义为抽象类


> 接口的设计目的是为了对类的行为进行约束，只管行为有无，不管如何实现 --> 关注操作时使用
>   + 表达like a的关系: Birds like an Aircraft(像飞行器一样可以飞 但本质上是bird而非aircraft)
>   + 接口核心是定义行为，仅约束类可以做什么，至于是谁做、如何实现则并不关心

由上述对比可知：
抽象类需要写出所有子类的共性，定义的代价更大(Java语言每个类只能继承一个类)。<br>
接口在功能上做了大量简化，仅仅针对动作行为的描述，且可以在一个类中实现多个接口，设计时会降低难度。

## 举例：<br>
> java.io.InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这意味着什么？
> 意味着InputStream是不能直接实例化的 只有它的实现子类才能够实例化

> 而练题过程中间做的一个又一个比较器呢？ xxx implements Comparator<泛型> 这是接口