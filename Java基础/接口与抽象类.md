# interface 与 abstract class
## 简要对比
|     抽象类     |                                                                接口                                                                |
|:-----------:|:--------------------------------------------------------------------------------------------------------------------------------:|
| 可以存在普通成员函数  |                    JDK7.0之前只能存在抽象方法 public abstract 但这两个关键字可以省略<br/> jdk8之后 接口中本身可以有静态方法的实现(但需要default关键字修饰)                     |
| 成员变量可以是各种类型 |                                       接口中的属性只能是public static final型(也就是常量型 这点易忽略， 关键字都可省略)                                       |
|   至多被继承一个   | 接口可以实现多个 如果一个类能implements接口 需要实现接口的所有抽象方法(接口中的抽象方法可以省略abstract关键字, alt+enter) <br/> 接口不能继承其他类 但可以继承多个别的接口(用extends而不是implements) |

## 深入对比
> 抽象类的设计目的是代码复用(联系Python语言的函数设计的目的) --> 关注提炼事物本质时使用
>   + 表达is a 的关系:  BMW is a Car. 对类本质进行抽象。
>   + 先有子类若干，再从中抽象出共性，提炼为抽象类。
>   + 如上所述，抽象类仅实现了子类间重叠的部分(个性部分未能实现)，所以不能实例化。
>   + 抽象类中不一定要有抽象方法，但只要出现了抽象方法（空壳子 定义个方法名字等待子类重写，不允许有方法体）就必须把类声明为抽象类
>     + 抽象方法需要被重写 所以拒绝使用private  final static来修饰
>     + 代码举例    public abstract void eat();    // 不加{} 方法体
>   + abstract 抽象 只能抽象类和抽象方法  不能作用于属性

>   + 抽象类也是类 所以有继承机制  如果一个类继承抽象类 必须继承抽象类的所有抽象方法 或者也定义为抽象类

> 接口的设计目的是为了对类的行为进行约束，只管行为有无，不管如何实现 --> 关注操作时使用
>   + 表达like a的关系: Birds like an Aircraft(像飞行器一样可以飞 但本质上是bird而非aircraft)
>   + 接口核心是定义行为，仅约束类可以做什么，至于是谁做、如何实现则并不关心
>   + 和抽象类类似  接口不能实例化
>   + 接口修饰符可以是public或者是默认不写
>   + 抽象类实现接口 可以不实现接口的抽象方法？？？

由上述对比可知：
抽象类需要写出所有子类的共性，定义的代价更大(Java语言每个类只能继承一个类)。<br>
接口在功能上做了大量简化，仅仅针对动作行为的描述，且可以在一个类中实现多个接口，设计时会降低难度。

## 接口和继承的补充关系
- 接口可以设计好一些子类继承到的父类属性之外的扩展方法 帮助子类实现父类没能做到的一些额外的功能
    - 接口通过设计好各种规范去做到
- 继承的价值则在于解决代码的复用性和可维护性
- 继承需要 is a  而接口只需要like a的关系   接口更灵活 在一定程度上依赖于接口的规范性+动态绑定来实现代码解耦

## 接口的多态具体体现
- 接口类型的变量  可以指向 实现了接口的类的对象实例 
```java
interface IF {}
class Monster implements IF{}

IF if = new Monster();
```

- 接口类型也可以做成数组    
```java
public static void main(String[]args){
    USB[] usbs = new USB[2];  //多态数组  可以使用多态放进去
    usbs[0] = new Phone_();       
    usbs[1] = new Camera_();
}


```


## 举例：<br>
> java.io.InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这意味着什么？
> 意味着InputStream是不能直接实例化的 只有它的实现子类才能够实例化

> 而练题过程中间做的一个又一个比较器呢？ xxx implements Comparator<泛型> 这是接口