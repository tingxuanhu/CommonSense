# 方法重载与方法重写辨析<br>

<table>
    <tr>
        <th></th><th>重载Overload</th><th>重写Override</th>
    </tr>
    <tr>
        <td>何时何处生效</td><td>同一个类中</td><td>子类中</td>
    <tr>
        <td>与被执行操作的方法间</td>
        <td colspan="2">方法名相同</td>
    </tr>
    <tr>
        <td rowspan="2">与被执行操作的方法之间不同点</td><td>参数的类型不同 个数不同 顺序不同</td><td>参数列表相同
    </tr>
    <tr>
        <td>方法返回值和访问修饰符可以不同(方法重载返回值类型通常相同)</td><td>访问修饰符范围不能缩小父类的访问权限，也就是要大于等于父类的访问权限（父类为private则不可在子类中被Override）
        <br/>
        返回值类型和父类类型相同或者是父类的子类
        <br/>
        抛出异常的范围是父类类型或者父类的子类类型
        <br/>
    </tr>
</table>


## example
> 比较器Comparator(本身是个接口  接口和抽象类有何区别？ 复习) 用子类去重写compare方法
```java
import java.util.Comparator;

...
public class BestArrange {
    public static class Program {
        ...
    }
    
    public static class ProgramComparator implements Comparator<Program> {
        @Override
        public int compare(Program p1, Program p2) {
          return o1.end - o2.end;
        }
    }

}

```
>一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名重载成同名方法
```java
class Hello {
    public void hello() {
        System.out.println("Hello, world!");
    }

    public void hello(String name) {
        System.out.println("Hello, " + name + "!");
    }

    public void hello(String name, int age) {
        if (age < 18) {
            System.out.println("Hi, " + name + "!");
        } else {
            System.out.println("Hello, " + name + "!");
        }
    }
}
```